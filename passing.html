<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Shape Minor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- for Google -->
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <meta name="author" content="M Lauren Maxwell" />

    <!-- for Facebook -->
    <meta property="og:title" content="Passing" />
    <meta property="og:type" content="webgl" />
    <meta property="og:image" content="" />
    <meta property="og:description" content="landscape rendering" />

    <!-- for Twitter -->
    <meta name="twitter:card" content="webgl" />
    <meta name="twitter:title" content="Shape Minor" />
    <meta name="twitter:description" content="rendering" />
    <meta name="twitter:image" content="glamour-gems.png" />
    <style>
      body {
        color: #888888;
        font-family:Monospace;
        font-size:13px;

        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 200px;
        left: calc(50% - 100px);
        text-align: center;
      }

      a {
        color: #00f;
      }
    </style>
  </head>
  <body>

    <div id="container"><div id="info">
      <a href="/">&lt;</a>
      debug</div></div>

    <script type="text/javascript" src="lib/three.js"></script>
    <script type="text/javascript" src="lib/physi.js"></script>
    <script type="text/javascript" src="lib/js/Mirror.js"></script>
    <script type="text/javascript" src="lib/js/controls/OrbitControls.js"></script>

  </body>
  <script>
      Physijs.scripts.worker = 'lib/physijs_worker.js';
      Physijs.scripts.ammo = 'ammo.js';

      var WIDTH = window.innerWidth;
      var HEIGHT = window.innerHeight;

      var VIEW_ANGLE = 50;
      var ASPECT = WIDTH / HEIGHT;

      var NEAR = 1;
      var FAR = 600;

      var camera, scene, renderer;

      var cameraControls;

      // --- Mirrors vars --- //
      var verticalMirror, groundMirror;

      var clock = new THREE.Clock();
      var lightVal = 0, lightDir = 1;

      // Returns a random number between min and max
      function getRandomArbitrary(min, max)
      {
        return Math.random() * (max - min) + min;
      }

      function init()
      {

        // - Renderer - //
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( WIDTH, HEIGHT );

         // - Scene - //
        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0.0001, -10, 0 ));

        scene.fog = new THREE.FogExp2( 0xe8e5f1, 0.005 );

        renderer.setClearColor( scene.fog.color, 1 );
        
        // - Camera - //
        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set( 400, 300, 300 );

        // - Orbit Camera Controls - //
        cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
        cameraControls.target.set( 0, 0, 0 );
        cameraControls.maxDistance = 100;
        cameraControls.minDistance = 10;
        cameraControls.update();

        raycaster = new THREE.Raycaster();

        // - Update the Camera - //
        var container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

      }

      function fillScene()
      {

        var planeGeoGround = new THREE.PlaneBufferGeometry( 2000, 2000 );

        var bumpMapTexture = THREE.ImageUtils.loadTexture( 'textures/donutTex.jpg' );
        bumpMapTexture.wrapS = bumpMapTexture.wrapT = THREE.RepeatWrapping;
        bumpMapTexture.repeat.set( 5, 5 );

        var planeBottom = new THREE.Mesh( planeGeoGround, new THREE.MeshPhongMaterial( { ambient: 0xB0C77B, color: 0xE8FED3, specular: 0xB0C77B, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        // planeRight.rotateY( Math.PI);
        planeBottom.rotateX( - Math.PI / 2 );
        scene.add( planeBottom );

        var planeGeo = new THREE.PlaneBufferGeometry( 100.1, 100.1 );

        // - Vertical Mirror Texture - //
        verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color: 0x889999, fog: true } );
        verticalMirrorMaterial = Physijs.createMaterial(
          verticalMirror.material,
          .8, // high friction
          .8 // low restitution
        );

        // - Add mirror texture to physical plane - //
        var mirrorMesh = new Physijs.BoxMesh  (
          planeGeo,
          verticalMirrorMaterial,
          0 // Mass
        );
        // var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
        mirrorMesh.add( verticalMirror );
        // mirrorMesh.rotateX( - Math.PI / 2 );
        scene.add( mirrorMesh );
        console.log( mirrorMesh );

        var CrystalGroup = new THREE.Group();

        // Generate random number of objects to be shown on the plane.

        /// TODO: give these items the ability to carry gravity
        var random = getRandomArbitrary(4, 50);
        for (var i = 0; i <= random; i++) {
          var geometry = new THREE.IcosahedronGeometry( 5, 0 );
          var material = new THREE.MeshLambertMaterial( { color: 0xffffff, emissive: 0x333333, shading: THREE.FlatShading } );
          var smallSphere = new THREE.Mesh( geometry, material );
          smallSphere.position.y = getRandomArbitrary(-50, 50);
          smallSphere.position.x = getRandomArbitrary(-50, 50);
          CrystalGroup.add(smallSphere);
        }
        scene.add(CrystalGroup); 

        // ---- Add all the lights ---- //
        scene.add( new THREE.AmbientLight( 0xa6a6a6 ) );

        directionalLight = new THREE.DirectionalLight( 0x7FA8C7, 1.25 );
        directionalLight.position.set( 500, 2000, 0 );
        scene.add( directionalLight );

        pointLight = new THREE.PointLight( 0x7FA8C7, 1.5 );
        pointLight.position.set( 0, 0, 0 );
        scene.add( pointLight );
        console.log(scene.children);
        document.addEventListener( 'mousedown', generateGravity, false );


      }

      function generateGravity(event)
      {
        event.preventDefault();

        var vector = new THREE.Vector3();
        vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
        vector.unproject( camera );

        raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

        //console.log(raycaster);

        var intersects = raycaster.intersectObjects( scene.children[2].children );

        console.log(intersects);

      }

      function render()
      {
        verticalMirror.renderWithMirror( verticalMirror );

        renderer.setClearColor( scene.fog.color, 1 );
        renderer.render(scene, camera);
      }

      function update()
      {
        requestAnimationFrame( update );

        cameraControls.update();

        render();
        scene.simulate();
      }

      init();
      fillScene();
      update();

  </script>
  <div id="container">
      
  </div>
</body>