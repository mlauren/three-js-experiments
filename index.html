<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Shape Minor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- for Google -->
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <meta name="author" content="M Lauren Maxwell" />

    <!-- for Facebook -->
    <meta property="og:title" content="Shape Minor" />
    <meta property="og:type" content="webgl" />
    <meta property="og:image" content="/glamour-gems.png" />
    <meta property="og:description" content="webgl rendering" />

    <!-- for Twitter -->
    <meta name="twitter:card" content="webgl" />
    <meta name="twitter:title" content="Shape Minor" />
    <meta name="twitter:description" content="rendering" />
    <meta name="twitter:image" content="glamour-gems.png" />
    <style>
      body {
        color: #888888;
        font-family:Monospace;
        font-size:13px;

        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 200px;
        left: calc(50% - 100px);
        text-align: center;
      }

      a {
        color: #00f;
      }
    </style>
  </head>
  <body>

    <div id="container"><div id="info"></div></div>

    <script type="text/javascript" src="lib/three.js"></script>
    <script type="text/javascript" src="lib/physi.js"></script>
    <script type="text/javascript" src="lib/js/Mirror.js"></script>
    <script type="text/javascript" src="lib/js/controls/OrbitControls.js"></script>


    <!-- ---------------- Custom Shader Code ------------------------ -->
    <script id="vertexShader" type="x-shader/x-vertex">
    uniform vec3 viewVector;
    uniform float c;
    uniform float p;
    varying float intensity;
    void main()
    {
      vec3 vNormal = normalize( normalMatrix * normal );
      vec3 vNormel = normalize( normalMatrix * viewVector );
      intensity = pow( c - dot(vNormal, vNormel), p );

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
    </script>

    <!-- fragment shader a.k.a. pixel shader -->
    <script id="fragmentShader" type="x-shader/x-vertex">
    uniform vec3 glowColor;
    varying float intensity;
    void main()
    {
      vec3 glow = glowColor * intensity;
        gl_FragColor = vec4( glow, .25 );
    }
    </script>
    <!-- ----------------------------------------------------------- -->
    <script>
      Physijs.scripts.worker = 'lib/physijs_worker.js';
      Physijs.scripts.ammo = 'ammo.js';

      var WIDTH = window.innerWidth;
      var HEIGHT = window.innerHeight;

      var VIEW_ANGLE = 50;
      var ASPECT = WIDTH / HEIGHT;

      var NEAR = 1;
      var FAR = 600;

      var camera, scene, renderer;

      var cameraControls;

      // --- Mirrors vars --- //
      var verticalMirror, groundMirror;

      var clock = new THREE.Clock();
      var lightVal = 0, lightDir = 1;

      var polyhedron;
      var group = new THREE.Group();

       // Returns a random number between min and max
      function getRandomArbitrary(min, max) {
        return Math.random() * (max - min) + min;
      }

      function init() {
        // - Renderer - //
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( WIDTH, HEIGHT );

        // - Scene - //
        scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
        scene.setGravity(new THREE.Vector3( 0.0001, -10, 0 ));

        scene.addEventListener(
        'update',
        function() {
            scene.simulate( undefined, 2 );
        });

        scene.fog = new THREE.FogExp2( 0xe8e5f1, 0.005 );

        renderer.setClearColor( scene.fog.color, 1 );
        
        // - Camera - //
        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set( 0, 45, 200 );

        // - Orbit Camera Controls - //
        cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
        cameraControls.target.set( 0, 50, 0 );
        cameraControls.maxDistance = 200;
        cameraControls.minDistance = 10;
        cameraControls.update();

        raycaster = new THREE.Raycaster();
        document.addEventListener( 'mousedown', generateObjects, false );

        // - Update the Camera - //
        var container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );
      }

      function generateNewCrystal() {

        var tinyGeometry = new THREE.SphereGeometry( 1, 5, 3 );
        tinyGeometry.mergeVertices();
        var tinyMaterial = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            ambient: 0xffffff,
            color: 0xcccccc,
            specular: 0xffffff,
            metal: true,
            fog: true,
            shininess: 200,
            shading: THREE.FlatShading,
            reflectivity: 30,
            transparent: true,
            opacity: .8
          }),
          -.1, // high friction
          1 // medium restitution /bouciness
        );
        var tinyPolyhedron = new Physijs.SphereMesh(
          tinyGeometry,
          tinyMaterial,
          1
        );
        tinyPolyhedron.position.set(getRandomArbitrary(120, -120),getRandomArbitrary(130, 0),getRandomArbitrary(120, -120));
        scene.add(tinyPolyhedron);
        // new TWEEN.Tween(tinyPolyhedron.material).to({opacity: 1}, 500).start();

      }

      // Generate an object when major gem is clicked
      function generateObjects(event) {
        event.preventDefault();

        var vector = new THREE.Vector3();
        vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
        vector.unproject( camera );

        raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObject( polyhedron );
        if (intersects.length === 1) {
          intersects[ 0 ].object.material.ambient.setHex( Math.random() * 0xffffff );
          // Generate a tiny new crystal
          for (var i = 0; i <= 30; i++) {
            generateNewCrystal();
          }
        }
      }

      function fillScene() {

        var planeGeo = new THREE.PlaneBufferGeometry( 100.1, 100.1 );

        // - Ground Mirror Texture - //
        groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color: 0x777777, fog: true } );
        groundMirrorMaterial = Physijs.createMaterial(
          groundMirror.material,
          .8, // high friction
          .8 // low restitution
        );
        // - Add mirror texture to physical plane - //
        var mirrorMesh = new Physijs.BoxMesh  (
          planeGeo,
          groundMirrorMaterial,
          0 // Mass
        );
        // var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
        mirrorMesh.add( groundMirror );
        mirrorMesh.rotateX( - Math.PI / 2 );
        scene.add( mirrorMesh );

        // - Vertical Mirror Texture - //
        verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color:0x889999, fog: true } );
        // - Add mirror texture to physical plane - //
        var verticalMirrorMesh = new THREE.Mesh( planeGeo, verticalMirror.material );
        verticalMirrorMesh.add( verticalMirror );
        verticalMirrorMesh.position.y = 50;
        verticalMirrorMesh.position.z = -50;
        scene.add( verticalMirrorMesh );

        var bumpMapTexture = THREE.ImageUtils.loadTexture( 'donutTex.jpg' );
        bumpMapTexture.wrapS = bumpMapTexture.wrapT = THREE.RepeatWrapping;
        bumpMapTexture.repeat.set( 5, 5 );

        //-- ** Add Glamour Objects Here ** --//
        // - Walls - //
        var planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x3D349D, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3 } ) );
        planeTop.position.y = 100;
        planeTop.rotateX( Math.PI / 2 );
        scene.add( planeTop );
        
        var planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xDAA1E5, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeFront.position.z = 50;
        planeFront.position.y = 50;
        planeFront.rotateY( Math.PI );
        scene.add( planeFront );
        
        var planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x9188D7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeRight.position.x = 50;
        planeRight.position.y = 50;
        planeRight.rotateY( - Math.PI / 2 );
        scene.add( planeRight );
        
        var planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7FA8C7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeLeft.position.x = -50;
        planeLeft.position.y = 50;
        planeLeft.rotateY( Math.PI / 2 );
        scene.add( planeLeft );

        // 0xDAA1E5 light pink
        // B6AFE3 // light purp pink
        // FF8EE3 hot pink

        var cylinder = new THREE.Mesh(
          // radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
          new THREE.CylinderGeometry( 3, 3, 103, 10, 4 ),
          new THREE.MeshPhongMaterial( { ambient: 0xB6AFE3, color: 0xB6AFE3, specular: 0xB6AFE3, fog: true} )
        );
        cylinder.position.set(19, 50, -36);
        cylinder.rotateY( Math.PI / 3.75 );
        cylinder.rotateZ( Math.PI / 1.09 );
        scene.add( cylinder );

        var mapTexture = new THREE.ImageUtils.loadTexture('crystal8.jpg', new THREE.CubeReflectionMapping() );
        mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
        mapTexture.repeat.set( 4, 4 );


        var geometry = new THREE.SphereGeometry( 20, 5, 3 );
        geometry.mergeVertices();
        var material = new THREE.MeshPhongMaterial( { ambient: new THREE.Color().setHex( Math.random() * 0xffffff ), color: 0xFF8EE3, specular: 0xffffff, bumpMap: mapTexture, fog: true, shininess: 50, shading: THREE.FlatShading, transparent: false, reflectivity: 10 } )
        polyhedron = new THREE.Mesh( geometry, material );
        polyhedron.position.set(0,0,0);
        scene.add(polyhedron);

        polyhedron.rotateX( Math.PI / 1.5);
        polyhedron.rotateY( -Math.PI / 3.75 );
        polyhedron.position.set(-28, 30, -20);

        // add the sphere to the scene
        group.add(polyhedron);

        // create custom material from the shader code above
        // that is within specially labeled script tags
        var sphere = new THREE.SphereGeometry( 20, 0, 0 );
        var customMaterial = new THREE.ShaderMaterial( 
        {
          uniforms:
          {
            "c":   { type: "f", value: 1.0 },
            "p":   { type: "f", value: 2.0 },
            glowColor: { type: "c", value: new THREE.Color(0xffd089) },
            viewVector: { type: "v3", value: camera.position }
          },
          vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          side: THREE.FrontSide,
          blending: THREE.AdditiveBlending,
          transparent: true
        }   );

        this.moonGlow = new THREE.Mesh( sphere, customMaterial.clone() );
        moonGlow.position.x = polyhedron.position.x;
        moonGlow.position.y = polyhedron.position.y;
        moonGlow.position.z = polyhedron.position.z;
        moonGlow.scale.multiplyScalar(1.33);
        group.add( moonGlow );


        var imagePrefix = "textures/skybox/bluefreeze_";
        var directions  = ["lf", "rt", "up", "dn", "ft", "bk"];
        // var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
        var imageSuffix = ".png";
        var skyGeometry = new THREE.BoxGeometry( 512, 512, 512 );

        var materialArray = [];
        for (var i = 0; i < 6; i++)
          materialArray.push( new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
            side: THREE.BackSide
          }));
        var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
        var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
        scene.add( skyBox );

        scene.add( new THREE.AmbientLight( 0xa6a6a6 ) );

        directionalLight = new THREE.DirectionalLight( 0x7FA8C7, 1.25 );
        directionalLight.position.set( 500, 2000, 0 );
        scene.add( directionalLight );

        pointLight = new THREE.PointLight( 0x7FA8C7, 1.5 );
        pointLight.position.set( 0, 0, 0 );
        scene.add( pointLight );

        scene.add(group);
      }

      function render() {
        groundMirror.renderWithMirror( verticalMirror );
        verticalMirror.renderWithMirror( groundMirror );

        renderer.setClearColor( scene.fog.color, 1 );

        renderer.render(scene, camera);
      }

      function update() {
        requestAnimationFrame( update );
        var timer = Date.now() * 0.01;

        var lightVal = 0, time = Date.now() * 0.001;

        /*--- Render changes to lighting --- */
        var delta = clock.getDelta();

        var fLow = 0.1, fHigh = 0.8;

        lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

        var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );


        directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
        pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

        /*--- end render changes to lighting --- */
        /*--- render animation --- */
        polyhedron.rotation.x+=2/200;
        polyhedron.rotation.y+=2/200;
        moonGlow.rotation.x+=2/200;
        moonGlow.rotation.y+=2/200;

        var axis = new THREE.Vector3(0.15,0,0.005);
        var increment = 0;

        increment += 9/100;
        group.rotateOnAxis(axis,increment);

        cameraControls.update();

        render();
        scene.simulate();
      }

      init();
      fillScene();
      update();

    </script>
    <div id="container">
      
    </div>
  </body>
