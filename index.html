<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Gem Minor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #888888;
        font-family:Monospace;
        font-size:13px;

        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 200px;
        left: calc(50% - 100px);
        text-align: center;
      }

      a {
        color: #00f;
      }
    </style>
  </head>
  <body>

    <div id="container"></div>
    <div id="info"><a href="http://threejs.org" target="_blank">gem minor</a>
    </div>

    <script src="lib/three.js"></script>
    <script src="lib/js/Mirror.js"></script>
    <script src="lib/js/WaterShader.js"></script>
    <script src="lib/js/controls/OrbitControls.js"></script>

    <script>
      var WIDTH = window.innerWidth;
      var HEIGHT = window.innerHeight;

      var VIEW_ANGLE = 50;
      var ASPECT = WIDTH / HEIGHT;

      var NEAR = 1;
      var FAR = 600;

      var camera, scene, renderer;

      var cameraControls;

      // --- Mirrors vars --- //
      var verticalMirror, groundMirror;
      var sphereGroup, smallSphere;

      var clock = new THREE.Clock();
      var lightVal = 0, lightDir = 1;

      var polyhedron;

      function init() {
        // - Renderer - //
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( WIDTH, HEIGHT );

        // - Scene - //
        scene = new THREE.Scene();
        // scene.fog = new THREE.FogExp2( 0xefd1b5, 0.0000025 );
        scene.fog = new THREE.FogExp2( 0xe8e5f1, 0.005 );

        renderer.setClearColor( scene.fog.color, 1 );
        
        // - Camera - //
        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set( 0, 45, 200 );

        // - Orbit Camera Controls - //
        cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
        cameraControls.target.set( 0, 50, 0 );
        cameraControls.maxDistance = 250;
        cameraControls.minDistance = 10;
        cameraControls.update();

        raycaster = new THREE.Raycaster();
        document.addEventListener( 'mousedown', generateObjects, false );

        // - Update the Camera - //
        var container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

      }

      // Generate new minor gems


      // Generate an object when major gem is clicked
      function generateObjects(event) {
        event.preventDefault();

        var vector = new THREE.Vector3();
        vector.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
        vector.unproject( camera );

        raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObject( polyhedron );
        if (intersects.length === 1) {
          intersects[ 0 ].object.material.ambient.setHex( Math.random() * 0xffffff );
        }

      }

      function fillScene() {

        var planeGeo = new THREE.PlaneBufferGeometry( 100.1, 100.1 );

        // - Ground Mirror Texture - //
        groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color: 0x777777 } );
        // - Add mirror texture to physical plane - //
        var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
        mirrorMesh.add( groundMirror );
        mirrorMesh.rotateX( - Math.PI / 2 );
        scene.add( mirrorMesh );

        // - Vertical Mirror Texture - //
        verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color:0x889999, fog: true } );
        // - Add mirror texture to physical plane - //
        var verticalMirrorMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 60, 60 ), verticalMirror.material );
        verticalMirrorMesh.add( verticalMirror );
        verticalMirrorMesh.position.y = 35;
        verticalMirrorMesh.position.z = -45;
        scene.add( verticalMirrorMesh );

        var bumpMapTexture = THREE.ImageUtils.loadTexture( 'donutTex.jpg' );
        bumpMapTexture.wrapS = bumpMapTexture.wrapT = THREE.RepeatWrapping;
        bumpMapTexture.repeat.set( 5, 5 );


        //mapTexture.repeat.set( 2, 2 );

        // 0xDAA1E5 light pink
        // B6AFE3 // light purp pink
        // FF8EE3 hot pink

        //-- ** Add Glamour Objects Here ** --//
        // - Walls - //
        var planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x3D349D, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3 } ) );
        planeTop.position.y = 100;
        planeTop.rotateX( Math.PI / 2 );
        scene.add( planeTop );
        
        var planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xB6AFE3, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeBack.position.z = -50;
        planeBack.position.y = 50;
        scene.add( planeBack );
        
        var planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xDAA1E5, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeFront.position.z = 50;
        planeFront.position.y = 50;
        planeFront.rotateY( Math.PI );
        scene.add( planeFront );
        
        var planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x9188D7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeRight.position.x = 50;
        planeRight.position.y = 50;
        planeRight.rotateY( - Math.PI / 2 );
        scene.add( planeRight );
        
        var planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7FA8C7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeLeft.position.x = -50;
        planeLeft.position.y = 50;
        planeLeft.rotateY( Math.PI / 2 );
        scene.add( planeLeft );


         // 0xDAA1E5 light pink
        // B6AFE3 // light purp pink
        // FF8EE3 hot pink

        var cylinder = new THREE.Mesh(
          // radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
          new THREE.CylinderGeometry( 3, 3, 103, 10, 4 ),
          new THREE.MeshPhongMaterial( { ambient: 0xB6AFE3, color: 0xB6AFE3, specular: 0xB6AFE3, fog: true} )
        );
        cylinder.position.set(19, 50, -36);
        cylinder.rotateY( Math.PI / 3.75 );
        cylinder.rotateZ( Math.PI / 1.09 );
        scene.add( cylinder );

        var mapTexture = new THREE.ImageUtils.loadTexture('crystal8.jpg', new THREE.CubeReflectionMapping() );
        mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
        mapTexture.repeat.set( 4, 4 );


        var geometry = new THREE.SphereGeometry( 20, 5, 3 );
        geometry.mergeVertices();
        var material = new THREE.MeshPhongMaterial( { ambient: 0xFF70A5, color: 0xFF8EE3, specular: 0xffffff, bumpMap: mapTexture, fog: true, shininess: 50, shading: THREE.FlatShading, transparent: false, reflectivity: 10 } )
        polyhedron = new THREE.Mesh( geometry, material );
        polyhedron.position.set(0,0,0);
        scene.add(polyhedron);

        polyhedron.rotateX( Math.PI / 1.5);
        polyhedron.rotateY( -Math.PI / 3.75 );
        polyhedron.position.set(-28, 30, -20);

        // add the sphere to the scene
        scene.add(polyhedron);


        var imagePrefix = "textures/skybox/bluefreeze_";
        var directions  = ["lf", "rt", "up", "dn", "ft", "bk"];
        // var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
        var imageSuffix = ".png";
        var skyGeometry = new THREE.BoxGeometry( 512, 512, 512 );

        var materialArray = [];
        for (var i = 0; i < 6; i++)
          materialArray.push( new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
            side: THREE.BackSide
          }));
        var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
        var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
        scene.add( skyBox );

        scene.add( new THREE.AmbientLight( 0xa6a6a6 ) );

        directionalLight = new THREE.DirectionalLight( 0x7FA8C7, 1.25 );
        directionalLight.position.set( 500, 2000, 0 );
        scene.add( directionalLight );

        pointLight = new THREE.PointLight( 0x7FA8C7, 1.5 );
        pointLight.position.set( 0, 0, 0 );
        scene.add( pointLight );

      }

      function render() {
        // render (update) the mirrors
        groundMirror.renderWithMirror( verticalMirror );
        verticalMirror.renderWithMirror( groundMirror );

        //scene.fog.color.setHSL( 0.45, 1, 0xfafafa );

        renderer.setClearColor( scene.fog.color, 1 );

        renderer.render(scene, camera);
      }

      function update() {
        requestAnimationFrame( update );

        var timer = Date.now() * 0.01;

        var lightVal = 0, time = Date.now() * 0.001;

        /*--- Render changes to lighting --- */
        var delta = clock.getDelta();

        var fLow = 0.1, fHigh = 0.8;

        lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

        var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );


        directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
        pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

        /*--- end render changes to lighting --- */
        /*--- render animation --- */
        polyhedron.rotation.x+=2/200;
        polyhedron.rotation.y+=2/200;

        cameraControls.update();

        render();
      }

      init();
      fillScene();
      update();

    </script>
    <div id="container">
      
    </div>
  </body>
