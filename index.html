<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - mirror</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #888888;
        font-family:Monospace;
        font-size:13px;

        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px;
        width: 200px;
        left: calc(50% - 100px);
        text-align: center;
      }

      a {
        color: #00f;
      }
    </style>
  </head>
  <body>

    <div id="container"></div>
    <div id="info"><a href="http://threejs.org" target="_blank"></a>
    </div>

    <script src="lib/three.js"></script>
    <script src="lib/js/Mirror.js"></script>
    <script src="lib/js/WaterShader.js"></script>
    <script src="lib/js/controls/OrbitControls.js"></script>


    <script type="application/x-glsl" id="sky-vertex">
      varying vec2 vUV;

      void main() {
        vUV = uv;
        vec4 pos = vec4(position, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * pos;
      }
      </script>

      <script type="application/x-glsl" id="sky-fragment">
      uniform sampler2D texture;
      varying vec2 vUV;

      void main() {
        vec4 sample = texture2D(texture, vUV);
        gl_FragColor = vec4(sample.xyz, sample.w);
      }
    </script>

    <script>
      var WIDTH = window.innerWidth;
      var HEIGHT = window.innerHeight;

      var VIEW_ANGLE = 50;
      var ASPECT = WIDTH / HEIGHT;

      var NEAR = 1;
      var FAR = 500;

      var camera, scene, renderer;

      var cameraControls;

      // --- Mirrors vars --- //
      var verticalMirror, groundMirror;
      var sphereGroup, smallSphere;

      var clock = new THREE.Clock();
      var lightVal = 0, lightDir = 1;

      var polyhedron;

      function init() {
        // - Renderer - //
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( WIDTH, HEIGHT );

        // - Scene - //
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0x111111, 2000, 4000 );

        renderer.setClearColor( scene.fog.color, 1 );
        
        // - Camera - //
        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set( 0, 45, 200 );

        // - Orbit Camera Controls - //
        cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
        cameraControls.target.set( 0, 50, 0 );
        cameraControls.maxDistance = 200;
        cameraControls.minDistance = 10;
        cameraControls.update();

        // - Update the Camera - //
        var container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

      }

      function fillScene() {

        var planeGeo = new THREE.PlaneBufferGeometry( 100.1, 100.1 );

        // - Ground Mirror Texture - //
        groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color: 0x777777 } );
        // - Add mirror texture to physical plane - //
        var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
        mirrorMesh.add( groundMirror );
        mirrorMesh.rotateX( - Math.PI / 2 );
        scene.add( mirrorMesh );

        // - Vertical Mirror Texture - //
        verticalMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, color:0x889999, fog: true } );
        // - Add mirror texture to physical plane - //
        var verticalMirrorMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 60, 60 ), verticalMirror.material );
        verticalMirrorMesh.add( verticalMirror );
        verticalMirrorMesh.position.y = 35;
        verticalMirrorMesh.position.z = -45;
        scene.add( verticalMirrorMesh );

        var bumpMapTexture = THREE.ImageUtils.loadTexture( 'donutTex.jpg' );
        bumpMapTexture.wrapS = bumpMapTexture.wrapT = THREE.RepeatWrapping;
        bumpMapTexture.repeat.set( 5, 5 );


        //mapTexture.repeat.set( 2, 2 );

        // 0xDAA1E5 light pink
        // B6AFE3 // light purp pink
        // FF8EE3 hot pink

        //-- ** Add Glamour Objects Here ** --//
        // - Walls - //
        var planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x3D349D, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3 } ) );
        planeTop.position.y = 100;
        planeTop.rotateX( Math.PI / 2 );
        scene.add( planeTop );
        
        var planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xB6AFE3, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeBack.position.z = -50;
        planeBack.position.y = 50;
        scene.add( planeBack );
        
        var planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xDAA1E5, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeFront.position.z = 50;
        planeFront.position.y = 50;
        planeFront.rotateY( Math.PI );
        scene.add( planeFront );
        
        var planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x9188D7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeRight.position.x = 50;
        planeRight.position.y = 50;
        planeRight.rotateY( - Math.PI / 2 );
        scene.add( planeRight );
        
        var planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7FA8C7, fog: true, bumpMap: bumpMapTexture, bumpScale: 0.3  } ) );
        planeLeft.position.x = -50;
        planeLeft.position.y = 50;
        planeLeft.rotateY( Math.PI / 2 );
        scene.add( planeLeft );


         // 0xDAA1E5 light pink
        // B6AFE3 // light purp pink
        // FF8EE3 hot pink

        var cylinder = new THREE.Mesh(
          // radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
          new THREE.CylinderGeometry( 3, 3, 103, 10, 4 ),
          new THREE.MeshPhongMaterial( { ambient: 0xB6AFE3, color: 0xB6AFE3, specular: 0xB6AFE3, fog: true} )
        );
        cylinder.position.set(19, 50, -36);
        cylinder.rotateY( Math.PI / 3.75 );
        cylinder.rotateZ( Math.PI / 1.09 );
        scene.add( cylinder );

        var mapTexture = new THREE.ImageUtils.loadTexture('crystal8.jpg', new THREE.CubeReflectionMapping() );
        mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
        mapTexture.repeat.set( 4, 4 );


        var geometry = new THREE.SphereGeometry( 20, 5, 3 );
        geometry.mergeVertices();
        var material = new THREE.MeshPhongMaterial( { ambient: 0xFF70A5, color: 0xFF8EE3, specular: 0xffffff, bumpMap: mapTexture, fog: true, shininess: 50, shading: THREE.FlatShading, transparent: true, opacity: .8, reflectivity: 10 } )
        polyhedron = new THREE.Mesh( geometry, material );
        polyhedron.position.set(0,0,0);
        scene.add(polyhedron);

        polyhedron.rotateX( Math.PI / 1.5);
        polyhedron.rotateY( -Math.PI / 3.75 );
        polyhedron.position.set(-28, 30, -20);

        // add the sphere to the scene
        scene.add(polyhedron);

        scene.add( new THREE.AmbientLight( 0xa6a6a6 ) );

        directionalLight = new THREE.DirectionalLight( 0x7FA8C7, 1.25 );
        directionalLight.position.set( 500, 2000, 0 );
        scene.add( directionalLight );

        pointLight = new THREE.PointLight( 0x7FA8C7, 1.5 );
        pointLight.position.set( 0, 0, 0 );
        scene.add( pointLight );

      }

      function render() {
        // render (update) the mirrors
        groundMirror.renderWithMirror( verticalMirror );
        verticalMirror.renderWithMirror( groundMirror );

        scene.fog.color.setHSL( 0.1, 1, 0xfafafa );

        renderer.setClearColor( scene.fog.color, 1 );

        renderer.render(scene, camera);
      }

      function update() {
        requestAnimationFrame( update );

        var timer = Date.now() * 0.01;

        var lightVal = 0, time = Date.now() * 0.001;

        /*--- Render changes to lighting --- */
        var delta = clock.getDelta();

        var fLow = 0.1, fHigh = 0.8;

        lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

        var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );


        directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
        pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

        /*--- end render changes to lighting --- */
        /*--- render animation --- */
        polyhedron.rotation.x+=2/200;
        polyhedron.rotation.y+=2/200;

        cameraControls.update();

        render();
      }

      init();
      fillScene();
      update();

    </script>
    <div id="container">
      
    </div>
  </body>
